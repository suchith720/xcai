# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/39_graph.operations.ipynb.

# %% auto 0
__all__ = ['Graph', 'perform_random_walk', 'perform_random_walk_with_matrices']

# %% ../../nbs/39_graph.operations.ipynb 2
import scipy.sparse as sp, numpy as np

from typing import Optional, List
from tqdm.auto import tqdm
from functools import partial
from xclib.utils.sparse import retain_topk

# %% ../../nbs/39_graph.operations.ipynb 3
class Graph:

    @staticmethod
    def batched_random_walk(
        data_lbl_indptr:List,
        data_lbl_indices:List,
        lbl_data_indptr:List,
        lbl_data_indices:List,
        data_start:int, 
        data_end:int,
        n_lbl:int,
        walk_to:Optional[int]=100, 
        prob_reset:Optional[float]=0.8, 
        n_hops:Optional[int]=1,
    ):
        n_data = data_end - data_start
        
        nbr_indices = np.zeros((n_data, walk_to), dtype=np.int32)
        nbr_data = np.zeros((n_data, walk_to), dtype=np.float32)
        for i in range(n_data):
            data_i = i + data_start
            for j in range(walk_to):
                p,q = data_lbl_indptr[data_i], data_lbl_indptr[data_i+1]
                if p == q: continue
                lbl_i = np.random.choice(data_lbl_indices[p:q])
                
                p,q = lbl_data_indptr[lbl_i], lbl_data_indptr[lbl_i+1]
                if p == q: continue
                data_i = np.random.choice(lbl_data_indices[p:q])
        
                nbr_indices[i, j] = data_i if n_hops == 2 else lbl_i
                nbr_data[i, j] = 1.0
                if np.random.random() < prob_reset: data_i = i + data_start
                
        nbr_indptr = np.arange(0, walk_to*(n_data+1), walk_to)
        
        matrix = sp.csr_matrix((nbr_data.flatten(), nbr_indices.flatten(), nbr_indptr), shape=(n_data, n_lbl), dtype=np.float32)
        matrix.eliminate_zeros()
        matrix.sum_duplicates()
        matrix.sort_indices()
    
        return matrix

    @staticmethod
    def random_walk(
        data_lbl:sp.csr_matrix, 
        walk_to:Optional[int]=100, 
        batch_size:Optional[int]=1024, 
        prob_reset:Optional[float]=0.8, 
        n_hops:Optional[int]=1,
    ):
        lbl_data = data_lbl.transpose()
        lbl_data = lbl_data.tocsr()
    
        data_lbl_indptr, data_lbl_indices = data_lbl.indptr, data_lbl.indices
        lbl_data_indptr, lbl_data_indices = lbl_data.indptr, lbl_data.indices
    
        n_lbl = data_lbl.shape[0] if n_hops == 2 else data_lbl.shape[1]
    
        walk_func = partial(Graph.batched_random_walk, data_lbl_indptr=data_lbl_indptr, data_lbl_indices=data_lbl_indices, 
                            lbl_data_indptr=lbl_data_indptr, lbl_data_indices=lbl_data_indices, walk_to=walk_to, prob_reset=prob_reset, 
                            n_hops=n_hops, n_lbl=n_lbl)
        
        return sp.vstack([walk_func(data_start=i, data_end=min(i+batch_size, data_lbl.shape[0])) for i in tqdm(range(0, data_lbl.shape[0], batch_size))])

    @staticmethod
    def batched_random_walk_with_matrices(
        data_meta_indptr:List,
        data_meta_indices:List,
        meta_lbl_indptr:List,
        meta_lbl_indices:List,

        lbl_meta_indptr:List,
        lbl_meta_indices:List,
        meta_data_indptr:List,
        meta_data_indices:List,
        
        data_start:int, 
        data_end:int,
        n_lbl:int,
        walk_to:Optional[int]=100, 
        prob_reset:Optional[float]=0.8, 
        n_hops:Optional[int]=1,
    ):
        n_data = data_end - data_start
        
        nbr_indices = np.zeros((n_data, walk_to), dtype=np.int32)
        nbr_data = np.zeros((n_data, walk_to), dtype=np.float32)
        for i in range(n_data):
            data_i = i + data_start
            for j in range(walk_to):
                p,q = data_meta_indptr[data_i], data_meta_indptr[data_i+1]
                if p == q: continue
                meta_i = np.random.choice(data_meta_indices[p:q])
                
                p,q = meta_lbl_indptr[meta_i], meta_lbl_indptr[meta_i+1]
                if p == q: continue
                lbl_i = np.random.choice(meta_lbl_indices[p:q])

                p,q = lbl_meta_indptr[lbl_i], lbl_meta_indptr[lbl_i+1]
                if p == q: continue
                meta_i = np.random.choice(lbl_meta_indices[p:q])

                p,q = meta_data_indptr[meta_i], meta_data_indptr[meta_i+1]
                if p == q: continue
                data_i = np.random.choice(meta_data_indices[p:q])

                if n_hops == 1: nbr_indices[i, j] = meta_i
                elif n_hops == 2: nbr_indices[i, j] = lbl_i
                elif n_hops == 3: nbr_indices[i, j] = data_i
                else: raise ValueError(f'Invalid number of hops: {n_hops}')
                
                nbr_data[i, j] = 1.0
                if np.random.random() < prob_reset: data_i = i + data_start
                
        nbr_indptr = np.arange(0, walk_to*(n_data+1), walk_to)
        
        matrix = sp.csr_matrix((nbr_data.flatten(), nbr_indices.flatten(), nbr_indptr), shape=(n_data, n_lbl), dtype=np.float32)
        matrix.eliminate_zeros()
        matrix.sum_duplicates()
        matrix.sort_indices()
    
        return matrix

    @staticmethod
    def random_walk_with_matrices(
        data_meta:sp.csr_matrix,
        lbl_meta:sp.csr_matrix,
        walk_to:Optional[int]=100, 
        batch_size:Optional[int]=1024, 
        prob_reset:Optional[float]=0.8, 
        n_hops:Optional[int]=1
    ):
        meta_data = data_meta.transpose().tocsr()
        meta_lbl = lbl_meta.transpose().tocsr()
    
        data_meta_indptr, data_meta_indices = data_meta.indptr, data_meta.indices
        meta_lbl_indptr, meta_lbl_indices = meta_lbl.indptr, meta_lbl.indices
        
        lbl_meta_indptr, lbl_meta_indices = lbl_meta.indptr, lbl_meta.indices
        meta_data_indptr, meta_data_indices = meta_data.indptr, meta_data.indices
        
        if n_hops == 1: n_lbl = data_meta.shape[1]
        elif n_hops == 2: n_lbl = lbl_meta.shape[0]
        elif n_hops == 3: n_lbl = data_meta.shape[0]
        else: raise ValueError(f'Invalid number of hops: {n_hops}')
        
        walk_func = partial(Graph.batched_random_walk_with_matrices, data_meta_indptr=data_meta_indptr, data_meta_indices=data_meta_indices, 
                            meta_lbl_indptr=meta_lbl_indptr, meta_lbl_indices=meta_lbl_indices, lbl_meta_indptr=lbl_meta_indptr, 
                            lbl_meta_indices=lbl_meta_indices, meta_data_indptr=meta_data_indptr, meta_data_indices=meta_data_indices, 
                            walk_to=walk_to, prob_reset=prob_reset, n_hops=n_hops, n_lbl=n_lbl)
        
        return sp.vstack([walk_func(data_start=i, data_end=min(i+batch_size, data_meta.shape[0])) for i in tqdm(range(0, data_meta.shape[0], batch_size))])

    @staticmethod
    def one_hop_matrix(data_lbl:sp.csr_matrix, batch_size:int=1024, topk:Optional[int]=None, do_normalize:Optional[bool]=False):
        data_lbl_t = data_lbl.transpose().tocsr()
        lbl_lbl = sp.vstack([data_lbl_t[i:i+batch_size]@data_lbl for i in tqdm(range(0, data_lbl_t.shape[0], batch_size))])
        data_lbl = sp.vstack([data_lbl[i:i+batch_size]@lbl_lbl for i in tqdm(range(0, data_lbl.shape[0], batch_size))])
        lbl_lbl.sort_indices()
        data_lbl.sort_indices()
        if topk is not None:
            data_lbl, lbl_lbl = retain_topk(data_lbl, k=topk), retain_topk(lbl_lbl, k=topk)
        if do_normalize:
            data_lbl = data_lbl / (data_lbl.sum(axis=1) + 1e-9)
            lbl_lbl = lbl_lbl / (lbl_lbl.sum(axis=1) + 1e-9)
        return data_lbl.tocsr(), lbl_lbl.tocsr()

    @staticmethod
    def threshold_on_degree(data_lbl:sp.csr_matrix, thresh:int=10):
        data_lbl = data_lbl.copy()
        idx = np.where(data_lbl.getnnz(axis=1) > thresh)[0]
        for i in idx:
            p,q = data_lbl.indptr[i],data_lbl.indptr[i+1]
            data_lbl.data[p:q] = 0
        data_lbl.eliminate_zeros()
        return data_lbl

    @staticmethod
    def normalize(mat):
        col_nnz = np.sqrt(1/(mat.sum(axis=0) + 1e-6))
        row_nnz = np.sqrt(1/(mat.sum(axis=1)+ 1e-6))
        mat = r_diags.multiply(row_nnz).multiply(col_nnz)
        mat.tocsr(); mat.eliminate_zeros()
        return mat
        

# %% ../../nbs/39_graph.operations.ipynb 4
def perform_random_walk(
    data_lbl:sp.csr_matrix, 
    batch_size:Optional[int]=1024, 
    walk_to:Optional[int]=100, 
    prob_reset:Optional[float]=0.8, 
    n_hops:Optional[int]=2,
    thresh:Optional[int]=None,
    topk:Optional[int]=None,
    do_normalize:Optional[bool]=False,
):
    if thresh is not None: data_lbl = Graph.threshold_on_degree(data_lbl, thresh=thresh)
    data_lbl = Graph.random_walk(data_lbl, walk_to=walk_to, batch_size=batch_size, prob_reset=prob_reset, n_hops=n_hops)
    if topk is not None: data_lbl = retain_topk(data_lbl, k=topk)
    if do_normalize: data_lbl = data_lbl / (data_lbl.sum(axis=1) + 1e-9)
    return data_lbl.tocsr()
    

# %% ../../nbs/39_graph.operations.ipynb 5
def perform_random_walk_with_matrices(
    data_meta:sp.csr_matrix,
    lbl_meta:sp.csr_matrix,
    batch_size:Optional[int]=1024, 
    walk_to:Optional[int]=100, 
    prob_reset:Optional[float]=0.8, 
    n_hops:Optional[int]=2,
    data_thresh:Optional[int]=None,
    lbl_thresh:Optional[int]=None,
    topk:Optional[int]=None,
    do_normalize:Optional[bool]=False,
):
    if data_thresh is not None: data_meta = Graph.threshold_on_degree(data_meta, thresh=data_thresh)
    if lbl_thresh is not None: lbl_meta = Graph.threshold_on_degree(lbl_meta, thresh=lbl_thresh)
    
    data_lbl = Graph.random_walk_with_matrices(data_meta, lbl_meta, walk_to=walk_to, batch_size=batch_size, prob_reset=prob_reset, n_hops=n_hops)
    
    if topk is not None: data_lbl = retain_topk(data_lbl, k=topk)
    if do_normalize: data_lbl = data_lbl / (data_lbl.sum(axis=1) + 1e-9)
    return data_lbl.tocsr()
