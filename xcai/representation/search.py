# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/11_representation.search.ipynb.

# %% auto 0
__all__ = ['IndexSearch', 'BruteForceSearch']

# %% ../../nbs/11_representation.search.ipynb 2
import torch, hnswlib, numpy as np, torch.nn.functional as F
from typing import Optional, Union

from ..core import *

# %% ../../nbs/11_representation.search.ipynb 4
class IndexSearch:

    def __init__(self, 
                 index:Optional[hnswlib.Index]=None, 
                 space:Optional[str]='cosine', 
                 efc:Optional[int]=200, 
                 m:Optional[int]=16, 
                 efs:Optional[int]=50, 
                 n_bm:Optional[int]=50, 
                 n_threads:Optional[int]=84):
        store_attr('index,space,efc,m,efs,n_bm,n_threads')

    def build(self, data:Optional[Union[torch.Tensor,np.array]], info:Optional[Union[torch.Tensor,np.array]]=None):
        if info is None: info = np.arange(data.shape[0])
        if data.shape[0] != info.shape[0]: 
            raise ValueError(f'`data`({data.shape[0]}) and `info`({info.shape[0]}) should have same size.')
            
        if isinstance(data, torch.Tensor): data = data.cpu()
        if isinstance(info, torch.Tensor): info = info.cpu()
            
        self.index = hnswlib.Index(space=self.space, dim=data.shape[1])
        self.index.init_index(max_elements=data.shape[0], ef_construction=self.efc, M=self.m)
        self.index.add_items(data, info, num_threads=self.n_threads)
        self.index.set_ef(self.efs)

    def proc(self, inputs:Optional[Union[torch.Tensor,np.array]], n_bm:Optional[int]=None):
        n_bm = self.n_bm if n_bm is None else n_bm
        n_bm = self.efs if n_bm > self.efs else n_bm
        if isinstance(inputs, torch.Tensor): inputs = inputs.cpu()
        info, sc = self.index.knn_query(inputs, k=n_bm)
        info, sc, ptr = torch.tensor(info.reshape(-1).astype(np.int64)), torch.tensor(sc.reshape(-1)), torch.full((inputs.shape[0],), n_bm)
        return {'info2data_idx':info, 'info2data_score':1.0-sc, 'info2data_data2ptr':ptr}
        

# %% ../../nbs/11_representation.search.ipynb 12
class BruteForceSearch:
    
    def __init__(self, 
                 index:Optional[torch.Tensor]=None, 
                 n_bm:Optional[int]=50):
        store_attr('index,n_bm')
        
    def build(self, data:Optional[torch.Tensor], info:Optional[torch.Tensor]=None):
        if info is not None and data.shape[0] != info.shape[0]: 
            raise ValueError(f'`data`({data.shape[0]}) and `info`({info.shape[0]}) should have same size.')
        self.index = (F.normalize(data, dim=1), info)
    
    def proc(self, inputs:Optional[torch.Tensor], n_bm:Optional[int]=None):
        store_attr('n_bm', is_none=False)
        index, info = self.index
        inputs, n_bm = F.normalize(inputs, dim=1), min(index.shape[0], self.n_bm)
        
        sc, idx = torch.topk(inputs@index.T, n_bm, dim=1, largest=True)
        if info is None: info = idx
        else: info = info.unsqueeze(0).expand((idx.shape[0],-1)).gather(1, idx)
            
        info, sc, ptr = info.reshape(-1), sc.reshape(-1), torch.full((inputs.shape[0],), n_bm, device=inputs.device)
        return {'info2data_idx':info, 'info2data_score':sc, 'info2data_data2ptr':ptr}
        
