# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/11_representation.index.ipynb.

# %% auto 0
__all__ = ['IndexSearch']

# %% ../../nbs/11_representation.index.ipynb 2
import torch, hnswlib, numpy as np
from typing import Optional, Union

from ..core import *

# %% ../../nbs/11_representation.index.ipynb 4
class IndexSearch:

    def __init__(self, 
                 index:Optional[hnswlib.Index]=None, 
                 space:Optional[str]='l2', 
                 efc:Optional[int]=200, 
                 m:Optional[int]=16, 
                 efs:Optional[int]=50, 
                 n_bm:Optional[int]=50, 
                 n_threads:Optional[int]=84):
        store_attr('index,space,efc,m,efs,n_bm,n_threads')

    def build(self, data:Optional[Union[torch.Tensor,np.array]], info:Optional[Union[torch.Tensor,np.array]]=None):
        if info is None: info = np.arange(data.shape[0])
        if data.shape[0] != info.shape[0]: 
            raise ValueError(f'`data`({data.shape[0]}) and `info`({info.shape[0]}) should have same size.')
            
        self.index = hnswlib.Index(space=self.space, dim=data.shape[1])
        self.index.init_index(max_elements=data.shape[0], ef_construction=self.efc, M=self.m)
        self.index.add_items(data, info, num_threads=self.n_threads)
        self.index.set_ef(self.efs)

    def proc(self, inputs:Optional[Union[torch.Tensor,np.array]], n_bm:Optional[int]=None):
        n_bm = self.n_bm if n_bm is None else n_bm
        n_bm = self.efs if n_bm > self.efs else n_bm
        info, sc = self.index.knn_query(inputs, k=n_bm)
        info, sc, ptr = torch.tensor(info.reshape(-1).astype(np.int64)), torch.tensor(sc.reshape(-1)), torch.full((inputs.shape[0],), n_bm)
        return {'info2data_idx':info, 'info2data_score':sc, 'info2data_data2ptr':ptr}
        
